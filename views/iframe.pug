extends index.pug
block content
  // basic spec:

  nav
    ul( class="c-tab__list")
      li(
        aria-controls="panel1"
        aria-expanded="true"
        aria-selected="true"
        class="c-tab__list__item is-selected"
        id="tab1"
        role="tab"
        tabindex="0") Macros 
      li(
        aria-controls="panel2"
        aria-expanded="false"
        aria-selected="false"
        class="c-tab__list__item"
        id="tab2"
        role="tab"
        tabindex="-1") Dynamic Content
    div(aria-hidden="false"
      aria-labelledby="tab1"
      class="c-tab__panel"
      id="panel1"
      role="tabpanel") 


      // macro tools
      div(class='container-fluid')
        // div(class='row')
        //   input(
        //     class="c-chk__input"
        //     id="tgl-0" 
        //     type="checkbox")
        //   label(
        //     class="c-chk__label c-chk__label--toggle" 
        //     for="tgl-0").c-chk__label.c-chk__label--toggle
        div(class='row')
          // form(class='width-300')
          div(class='col-md-4')
            label(class='c-txt__label',
              for='actionType') Find macros that set
            select(id='actionType',
              class='c-txt__input c-txt__input--select')

              option Choose an Action
              option Title
              option Description
              option Subject
              option Brand
              option Status
              option Form
              option Priority
              option Type
              option Group
              option Assignee
              option Set Tags
              option Remove Tags
              option Add CC
              option Comment
              option Comment Mode
              option Active
          // label(class='c-txt__label',
          //   for='actionType') Find a macro that has
          div(class='col-md-4')
            label(class='c-txt__label') to
            select(id='actionQueryValue',
              class='c-txt__input c-txt__input--select')
                option Is set to this
            input(type='text',
              id='actionQueryText',
              class='c-txt__input')
            div(class="c-chk",
              id='checkSensitiveWrapper')
              input(class="c-chk__input", 
                id="checkCaseSensitive", 
                type="checkbox")
              label(class="c-chk__label is-hidden", 
                id="checkSensitiveWrapperLabel",
                for="checkCaseSensitive") Case Sensitive
            // span(class='chk-spacer')



        div(class='row')
          div(class='col-md-12')
            h1(style="font-size:1.5em; margin:20px 0 0 0;") Macro Results
            table(class="c-table u-mb",
              id='macro-results')
              thead
                tr(class="c-table__row c-table__row--header")
                  th(class="c-table__row__cell c-table__row__cell--min") 
                  th(class="c-table__row__cell c-table__row__cell--min td-vert")
                    div(class="c-chk")
                      input(class="c-chk__input", 
                        id="check-all", 
                        type="checkbox")
                      label(class="c-chk__label is-hidden",
                        for="check-all")
                  th(class="c-table__row__cell") Title
                  th(class="c-table__row__cell"
                    id='macro-results-match-th') Matched
                  th(class="c-table__row__cell") Link
              tbody



        div(class='row')
          // form(class='width-300')
          div(class='col-md-4')
            label(class='c-txt__label',
              for='replaceType') Replace field
            select(id='replaceType',
              class='c-txt__input c-txt__input--select')
              option Choose an Action
              option Title
              option Description
              option Subject
              option Group Permission
              option Status
              option Brand
              option Form
              option Priority
              option Type
              option Group
              option Assignee
              option Set Tags
              option Remove Tags
              option Add CC
              option Comment
              option Comment Mode
              option Active
          div(class='col-md-4')
            label(class='c-txt__label') Replace Value
            select(id='replaceSelectValue',
              class='c-txt__input c-txt__input--select')
            input(type='text',
              id='replaceText',
              class='c-txt__input')
            div(class="c-chk",
              id='checkReplaceWordWrapper')
              input(class="c-chk__input", 
                id="checkReplaceWord", 
                type="checkbox")
              label(class="c-chk__label is-hidden", 
                id="checkReplaceWordWrapperLabel",
                for="checkReplaceWord") Replace Word
        div(class='row',
          id='replaceWordWrapper')
          div(class='col-md-4')
            label(class='c-txt__label') Replace Word
            input(type='text',
              id='replaceWordOriginal',
              class='c-txt__input')
          div(class='col-md-4')
            label(class='c-txt__label') With
            input(type='text',
              id='replaceWordNew',
              class='c-txt__input')
        div(class='row',
          id='groupTagWrapper')
          div(class='col-md-4')
          div(class='col-md-4')
            div(class='groupTagWrapper')
              div(class='c-txt__input c-txt__input--tag', id='groupTags')
                form(id="groupTagForm", name="groupTagForm")
                  div(class="typeahead__container")
                    div(class="typeahead__field",
                      id='typeAheadField')


                      div(id='groupTagList')
                      span(class="typeahead__query"
                        style='width:auto;')

                        input(class='tagTypeAhead condensed-input', 
                        value='', 
                        id='groupTagInput',
                        style='width:auto;')
        div(class='row')
          div(class='col-md-4')
            input(type='button',
              value='Update',
              id='updateButton',
              class='standardButton c-btn c-btn--primary')
          div(class='col-md-4')
            input(type='button',
              value='Upload Macros CSV',
              id='uploadMacroCSV',
              class='standardButton c-btn c-btn--primary u-bg-lime-M400 u-fg-white')
            input(type='button',
              value='',
              id='uploadMacroCSVStatus',
              class='standardButton c-btn c-btn--primary u-bg-white u-fg-black blankButton')
            input(type='file',
              id='macroCSVFile',
              style="display:none")
        div(class='row')
          div(class='col-md-4')
          div(class='col-md-4')
            a(href='https://support.zendesk.com/hc/en-us/community/posts/115006131447-How-to-export-Zendesk-macros-into-a-spreadsheet' target='_blank') Guide to get a properly formed CSV file for upload
        // h2 debug/testing text below
        // div(id='macroListWrapper')
        //   // a deal
        //   h2 List of Macros 
        //   // div
        //   // div(class='l-grid u-mb', id='macros')
        //   div(id='macros')
        // div(id='groupListWrapper')
        //   // a deal
        //   h2 List of Groups
        //   // div
        //   // div(class='l-grid u-mb', id='macros')
        //   div(id='groups')
        //   h2 Find macros that set group to:
        //   select(class="c-txt__input c-txt__input--select condensed-input dark-select",
        //   id='groupSelect')
        //     option(value="default") Choose a Group




        // div(class='groupTagWrapper')
        //   div(class='c-txt__input c-txt__input--tag', id='groupTags')
        //     form(id="groupTagForm", name="groupTagForm")
        //       div(class="typeahead__container")
        //         div(class="typeahead__field",
        //           id='typeAheadField')


        //           div(id='groupTagList')
        //           span(class="typeahead__query"
        //             style='width:auto;')

        //             input(class='tagTypeAhead condensed-input', 
        //             value='', 
        //             id='groupTagInput',
        //             style='width:auto;')

        // div(class='stuff1')
        //   form( id="groupTagForm", name="groupTagForm")
        //     div(id='groupTagList')
        //     div(class="typeahead__container")
        //       div(class="typeahead__field")
        //         span(class="typeahead__query")
        //           input(class='tagTypeAhead condensed-input', value='', id='groupTagInput')

    div(aria-hidden="true"
      aria-labelledby="tab2"
      class="c-tab__panel"
      id="panel2"
      role="tabpanel") 

      // Dynamic Content
      div(class='container-fluid')
        div(class='row')
          // form(class='width-300')
          div(class='col-md-4')
            label(class='c-txt__label',
              for='dynamicType') Find Dynamic Content
            select(id='dynamicType',
              class='c-txt__input c-txt__input--select')

              option Choose Item Title or Variant
              option Item
              option Variant
          div(class='col-md-4')
            label(class='c-txt__label') Value (case insensitive)
            input(type='text',
              id='dynamicQueryText',
              class='c-txt__input')
            div(class="c-chk",
              id='checkDynamicSensitiveWrapper')
              input(class="c-chk__input", 
                id="checkDynamicCaseSensitive", 
                type="checkbox")
              // label(class="c-chk__label is-hidden", 
              label(class="c-chk__label", 
                id="checkDynamicSensitiveWrapperLabel",
                for="checkDynamicCaseSensitive") Case Sensitive
            // span(class='chk-spacer')


        div(class='row')
          div(class='col-md-12')
            h1(style="font-size:1.5em; margin:20px 0 0 0;") Dynamic Content Results
            table(class="c-table u-mb",
              id='dynamic-results')
              thead
                tr(class="c-table__row c-table__row--header")
                  th(class="c-table__row__cell c-table__row__cell--min") 
                  th(class="c-table__row__cell c-table__row__cell--min td-vert")
                    div(class="c-chk")
                      input(class="c-chk__input", 
                        id="dynamic-check-all", 
                        type="checkbox")
                      label(class="c-chk__label is-hidden",
                        for="dynamic-check-all")
                  th(class="c-table__row__cell") Item Title
                  th(class="c-table__row__cell"
                    id='dynamic-results-match-th') Variant
                  th(class="c-table__row__cell") Link
                  th(class="c-table__row__cell") Variant Link
              tbody



        div(class='row')
          // form(class='width-300')
          div(class='col-md-4')
            label(class='c-txt__label',
              for='replaceDynamicType') Replace
            select(id='replaceDynamicType',
              class='c-txt__input c-txt__input--select')
              option Variant Text
          div(class='col-md-4')
            label(class='c-txt__label') Replace Value
            input(type='text',
              id='replaceDynamicText',
              class='c-txt__input')
            div(class="c-chk",
              id='checkDynamicReplaceWordWrapper')
              input(class="c-chk__input", 
                id="checkDynamicReplaceWord", 
                type="checkbox")
              label(class="c-chk__label", 
                for="checkReplaceWord") Replace Word
        div(class='row',
          id='replaceDynamicWordWrapper')
          div(class='col-md-4')
            label(class='c-txt__label') Replace Word
            input(type='text',
              id='replaceDynamicWordOriginal',
              class='c-txt__input')
          div(class='col-md-4')
            label(class='c-txt__label') With
            input(type='text',
              id='replaceDynamicWordNew',
              class='c-txt__input')
        div(class='row')
          div(class='col-md-4')
            input(type='button',
              value='Update',
              id='updateDynamicButton',
              class='standardButton c-btn c-btn--primary')



    // form(id="form-country_v1", name="form-country_v1")
    //   div(class="typeahead__container")
    //     div(class="typeahead__field")
    //       div(class="typeahead__query")
    //         input(class="tagTypeAhead", 
    //           name="country_v1[query]", 
    //           type="search", 
    //           placeholder="Search", 
    //           autocomplete="off")

  script(type='text/javascript').
    // Initialise the Zendesk JavaScript API client
    // const tempTag = jQuery('<div/>').attr('class', 'c-tag c-tag--sm c-tag--light c-tag--pill tagW')
    const debug = true

    debug && console.log("starting javascript in app")
    var client = ZAFClient.init();
    client.invoke('resize', { width: '100%', height: '700px' });

    // https://developer.zendesk.com/apps/docs/support-api/ticket_sidebar#ticket.type
    client.get('ticket.type')
    .then(data=>{
      jQuery('#ticketType').text(data['ticket.type'])
    })



    // hide actionQueryText and just show select by default
    debug && console.log("getting requester")

    debug && console.log("getting all macros")
    // getAllMacros()
    let allMacros = []
    let allDynamicItems = []
    let allGroups = []
    let allCustomTicketFields = []
    getAllMacrosAPI()
    .then(data=>{
      debug && console.log("echoing out datamacros ", data)
      addMacros(data.macros)
      allMacros = data.macros
    })
    getAllDynamicContentAPI()
    .then(data=>{
      debug && console.log("echoing out dynamic content: ", data)
      allDynamicItems = data.items
    })
    getAllTicketFields()
    .then(data=>{
      debug && console.log("echoing out tickets content: ", data)
      data.ticket_fields.forEach(item=>{
        if(item.type == 'checkbox' || item.custom_field_options)
          allCustomTicketFields.push(item)
      })
      debug && console.log("all custom ticket fields: ", allCustomTicketFields)

      // add custom ticket field choices if any
      if(allCustomTicketFields.length > 0){
        addTypeChoices()
        updateLookupWithCustomFields()
      }
    })
    debug && console.log("getting all groups")
    getGroups()
    .then(data=>{
      debug && console.log("got the data from groups API")
      debug && console.log(data)
      allGroups = data.groups
      // data.groups.forEach(group=>{
      //   debug && console.log("adding group: ", group)
      //   allGroups.push(group)
      // })
      // allGroups = [{name:'group 1', id:2}, {name:'group 2', id:3}]
      // addMacros(data.macros)
      // old test code
      // displayItems(data.groups, 'name', "#groups")
      // createDropDown(data.groups, 'name', '#groupSelect')
    })
    // debug && console.log("calling findGroups")
    // findGroups(360000820973)

    const statuses = []

    client.on('ticket.requester.id.changed', function(e){
      // refreshZenApp()
    })
    debug && console.log("getting context")
    let subdomain = null
    client.context().then(context=>{
      debug && console.log("context:", context)
      subdomain = context.account.subdomain
    })

    function loadInitialAppStuff(){
      userID = null
      email = null
      userDetails = {}
      ticketRequester = {}

      // get the agent user
      client.get('currentUser')
      .then(currentUserData=>{
        debug && console.log("Current user data: ", currentUserData)
        agentUser = currentUserData.currentUser
      })
    }


    function getAllMacros(){
      client.get('macros')
      .then(macroData=>{
        debug && console.log("MacroData: ", macroData)
        addMacros(macroData.macros)
      })
      .catch(err=>{
        debug && console.log("error getting macros: ", err)
      })
    }


    function getAllMacrosAPI(previousResults, nextPageURL){
      // same as above but use the API rest endpoint - 
      // https://developer.zendesk.com/apps/docs/developer-guide/using_sdk#working-with-requests
      // start with previous results if this is a new call
      debug && console.log("inside getallmacrosapi")
      const tempAllMacros = previousResults ? previousResults : {macros:[]}
      return new Promise((resolve, reject)=>{
        const macrosReq = {
            url: '/api/v2/macros.json',
            type: 'GET',
            dataType: 'json'
        }
        if(nextPageURL){
          const tempNextPage = nextPageURL.split('page=')[1]
          macrosReq.url += '?page='+tempNextPage
        }
        debug && console.log("macrosReq: ", macrosReq)
        client.request(macrosReq)
        .then(data=>{
          debug && console.log("got the data from macros API")
          debug && console.log(data)

          tempAllMacros.macros = tempAllMacros.macros.concat(data.macros)
          // continue to add new results until no more pagination
          if(data.next_page != null){ // should fail if null
            // get more results
            debug && console.log('getting more macros')
            getAllMacrosAPI(tempAllMacros, data.next_page)
            .then(data=>{
              resolve(data)
            })
          }else{
            debug && console.log('no more macros')
            resolve(tempAllMacros)
          }
        })
      })
    }

    // adds macros to the DOM
    function addMacros(macros){
      debug && console.log("addMacros:", macros)
      const macroElem = jQuery('#macros')
      macros.forEach(macro=>{
        debug && console.log("appending macros")
        const tempElem = jQuery('<h3 />').text(macro.title)
        // macroElem.append('<h3>test stuff</h3>')
        macroElem.append(tempElem)
      })
    }

    // TODO: get all ticket fields
    function getAllTicketFields(){
      return new Promise((resolve, reject)=>{
        const ticketsReq = {
            url: '/api/v2/ticket_fields.json',
            type: 'GET',
            dataType: 'json'
        }
        client.request(ticketsReq)
        .then(data=>{
          debug && console.log("got the data from tickets API")
          debug && console.log(data)
          resolve(data)
        })
      })
    }

    function getGroups(){
      return new Promise((resolve, reject)=>{
        debug && console.log("fetching groups")
        // https://developer.zendesk.com/apps/docs/developer-guide/using_sdk#working-with-requests
        const groupsReq = {
            url: '/api/v2/groups.json',
            type: 'GET',
            dataType: 'json'
        }
        client.request(groupsReq)
        .then(data=>{
          debug && console.log("returning getGroups() data")
          resolve(data)
        })
      })
    }

    // used for typeahead
    function getGroupsLocal(){
      return allGroups
    }

    function displayItems(items, field, elemID, clear){
      debug && console.log("inside display appending to:", elemID)
      const elemWrapper = jQuery(elemID)
      // clear all previous options
      if(clear){
        elemWrapper.html('')
      }
      items.forEach(item=>{
        debug && console.log("appending item: ", item)
        const tempElem = jQuery('<h3 />').text(item[field])
        // macroElem.append('<h3>test stuff</h3>')
        debug && console.log("tempElem in displayItems: ", tempElem)
        elemWrapper.append(tempElem)
      })
    }



    // partially disabled for now, use generic filter
    // TODO: new flow to add custom fields
    function findGroups(id){

      debug && console.log("calling getMacros for group:", id)
      getAllMacrosAPI()
      .then(data=>{
        const customFields = []
        debug && console.log("---Unfiltered macros: ", data.macros)
        filteredMacros = []
        data.macros.forEach(macro=>{
          debug && console.log('macro: ', macro)
          macro.actions.forEach(action=>{
            debug && console.log("macro action:", action)
            if(action.field == 'group_id'){
              debug && console.log("comparing: " + action.value + " to: " + id)
              if(parseInt(action.value) == id){
                debug && console.log("FOUDN GROUP CORRECT ID")
                filteredMacros.push(macro)
              }else{
                debug && console.log("NO ID MATCH")
              }
            }
          })
        })
        // debug && console.log("going to display macros")
        // displayItems(filteredMacros, 'title', '#results')
        
        // get all custom fields
        

        
      })
    }

    function createDropDown(items, titleKey, selectElem){
      debug && console.log(`Adding to ${selectElem}`, items)
      selectElem = jQuery(selectElem)
      debug && console.log(`Jqueried Adding: ${items} to `, selectElem)
      // selectElem.append('<option>Test</option>')
      items.forEach(item=>{
        // debug && console.log("titleKey: ", titleKey)
        // debug && console.log("id: ", item.id)
        // debug && console.log("<option value='"+item.id+"'>"+item[titleKey]+"</option> ")
        selectElem.append("<option value='"+item.id+"'>"+item[titleKey]+"</option> ")
        debug && console.log("appended option")
      })
      debug && console.log("done adding items to select")
    }

    function genericAPIReq(endpoint, filter){
      return new Promise((resolve, reject)=>{
        const APIReq = {
            url: '/api/v2/'+endpoint+'.json',
            type: 'GET',
            dataType: 'json'
        }
        if(filter){
          APIReq.url += '?'+filter
          debug && console.log(`Filter was `, filter)
        }else{
          debug && console.log(`Filter was empty`)
        }
        debug && console.log("api request to: ", APIReq.url)
        client.request(APIReq)
        .then(data=>{
          debug && console.log("got the data from  API: ", endpoint)
          debug && console.log(data)
          resolve(data)
        })
        .catch(err=>{
          debug && console.log("API Request Error")
          reject(err)
        })
      })
    }

    function genericAPIReqPut(endpoint, data){
      return new Promise((resolve, reject)=>{
        // const theData = data
        const jsonUploadData = JSON.stringify(data)
        // const jsonUploadData = data
        debug && console.log("json data: ", jsonUploadData)
        // specifying application/json is required
        const APIReq = {
            url: '/api/v2/'+endpoint+'.json',
            type: 'PUT',
            dataType: 'json',
            data:jsonUploadData,
            contentType:'application/json',
            httpCompleteResponse:true 
        }
        // no filter for PUT atm
        debug && console.log("api PUT request to: ", APIReq.url)
        client.request(APIReq)
        .then(respData=>{
          debug && console.log("got the data from  API: ", endpoint)
          debug && console.log(respData)
          const parsedData = JSON.parse(respData.responseText)
          debug && console.log("parsed data: ", parsedData)
          // append macro so its accessible on cb
          respData.macro = data.macro
          resolve(respData)
        })
        .catch(err=>{
          debug && console.log("PUT API Request Error", err)
          reject(err)
        })
      })
    }

    function genericAPIReqPost(endpoint, data){
      return new Promise((resolve, reject)=>{
        // const theData = data
        const jsonUploadData = JSON.stringify(data)
        // const jsonUploadData = data
        debug && console.log("json data: ", jsonUploadData)
        // specifying application/json is required
        const APIReq = {
            url: '/api/v2/'+endpoint+'.json',
            type: 'POST',
            dataType: 'json',
            data:jsonUploadData,
            contentType:'application/json',
            httpCompleteResponse:true 
        }
        // no filter for POST atm
        debug && console.log("api POST request to: ", APIReq.url)
        client.request(APIReq)
        .then(respData=>{
          debug && console.log("got the data from  API: ", endpoint)
          debug && console.log(respData)
          const parsedData = JSON.parse(respData.responseText)
          debug && console.log("parsed data: ", parsedData)
          // append macro so its accessible on cb
          respData.macro = data.macro
          resolve(respData)
        })
        .catch(err=>{
          debug && console.log("POST API Request Error", err)
          reject(err)
        })
      })
    }

    // TODO: update to add support for upsert, inserts if macro.id not set, genericAPIReq
    function sendManyAPIRequests(macros){
      // meter send macros
      const apiRequests = []
      debug && console.log("attempting to send multiple api requests for: ", macros)
      macros.forEach(macro=>{
        let requestURL = ''
        let request = ''
        // PUT for update, POST for insert 
        if(macro.id){
          requestURL = 'macros/'+macro.id        
          // macro.title += " - via API 3" // debug testing
          request = genericAPIReqPut(requestURL, {macro:macro})
        }else{
          requestURL = 'macros'        
          // macro.title += " - via API 3" // debug testing
          request = genericAPIReqPost(requestURL, {macro:macro})
        }
        apiRequests.push(request)
        // test bluebird
      })
      debug && console.log("attempting to Promise.map apiRequests: ", apiRequests)
      // use Promise.map for concurrency http://bluebirdjs.com/docs/api/promise.map.html
      Promise.map(apiRequests, function(data){
        debug && console.log("Inside of bluebird, returned data: ", data)
        // need to mark the item as updated
        // debug && console.log("updating displayMacros")
        debug && console.log("updating displayMacros")
        debug && console.log("original macro was: ", data.macro)
        updateMacroStatusNew(data.macro, null, 'success')
        // displayItems(macros, 'title', '#results', true)

      }, {concurrency:1})
      .then(()=>{
        debug && console.log("done updating macros")
        getAllMacrosAPI()
        .then(refreshedMacros=>{
          debug && console.log("refreshed macros")
          allMacros = refreshedMacros.macros
          // update csv status if it was a csv upload event - can promisify this function and bring up one level
          if(csvUploadDirty){
            uploadMacroCSVStatus.val('Uploaded')
            csvUploadDirty = false
          }
        })
      })
    }


    const replaceWordWrapper = $('#replaceWordWrapper')
    const checkSensitiveWrapper = $('#checkSensitiveWrapper')
    const checkSensitiveWrapperLabel = $('#checkSensitiveWrapperLabel')
    const checkReplaceWordWrapper = $('#checkReplaceWordWrapper')
    const checkReplaceWordWrapperLabel = $('#checkReplaceWordWrapperLabel')
    const groupTagWrapper = $('#groupTagWrapper')

    const groupTagList = jQuery('#groupTagList')

    const actionQuerySelect = $('#actionQueryValue')
    const actionQueryText = $('#actionQueryText')
    const actionType = jQuery('#actionType')
    const checkCaseSensitive = $('#checkCaseSensitive')
    const checkReplaceWord = $('#checkReplaceWord')
    const updateButton = $('#updateButton')
    const uploadMacroCSV = $('#uploadMacroCSV')
    const uploadMacroCSVStatus = $('#uploadMacroCSVStatus')
    const macroCSVFile = $('#macroCSVFile')
    const checkAll = $('#check-all')
    const replaceType = jQuery('#replaceType')
    const replaceSelectValue = jQuery('#replaceSelectValue')
    const replaceText = $('#replaceText')
    const replaceWordOriginal = $('#replaceWordOriginal')
    const replaceWordNew = $('#replaceWordNew')
    const prefixID = 'macro-result-'
    let isCaseSensitive = false
    let isReplaceWord = false
    let csvUploadDirty = false
    let currentLookup = null
    let replaceLookup = null
    let resultMacros = []

    actionQueryText.hide()
    checkSensitiveWrapper.hide()
    groupTagWrapper.hide()

    replaceText.hide()
    checkReplaceWordWrapper.hide()
    replaceWordWrapper.hide()

    const lookups = {
      Title: {api:'text', id:'title', meta:true, metaField:'title'},
      'Description':{api:'text', id:'description', meta:true, metaField:'description'},
      Brand: {api:'brands', title:'name', id:'brand_id'},
      Form: {api:'ticket_forms', title:'name', id:'ticket_form_id'},
      Group: {api:'groups', title:'name', id:'group_id', meta:true},
      'Group Permission': {api:'hardcoded', title:'name', id:'group_permissions', meta:true},
      Assignee: {api:'users', title:'name', filter:'role[]=admin&role[]=agent', id:'assignee_id'},
      'Add CC': {api:'users', title:'name', filter:'role[]=admin&role[]=agent', id:'cc'},
      'Subject':{api:'text', id:'subject'},
      'Set Tags':{api:'text', id:'set_tags'},
      'Remove Tags':{api:'text', id:'remove_tags'},
      'Comment':{api:'text', id:'comment_value_html', alt_id:'comment_value'},
      'Priority':{api:'hardcoded', id:'priority'},
      'Comment Mode':{api:'hardcoded', id:'comment_mode_is_public'},
      'Type':{api:'hardcoded', id:'type'},
      'Status':{api:'hardcoded', id:'status'},
      'Active':{api:'hardcoded', id:'active', meta:true, metaField:'active'},
    }
    // listeners
    // action choice - pull down related action stuff for action choice
    actionType.change(function(){
      // debug && console.log("action type choice: ", jQuery(this).value())
      debug && console.log("action type choice: ", $(this).val())
      debug && console.log("action type choice: ", $(this).val())
      // debug && console.log("action type choice: ", $(this).value())
      // option Choose an Action
      // option Subject - just text
      // option Priority - urgent high normal low
      // option Set Tags - space separated
      // option Remove Tags - space seperated
      // option Comment - text
      // option Comment Mode - boolean is public

      // option Brand - has API
      // option Form - form id, has API maybe
      // option Add CC - user id API maybe
      // option Group - group id API
      // option Assignee - user id API maybe
      // option Type - text but maybe can get from API
      lookupKey = $(this).val()
      lookup = lookups[$(this).val()]
      currentLookup = $(this).val()
      const endpoint = lookup.api

      // reset results
      resultMacros = []
      const macroTBody = $($('#macro-results').find('tbody')[0])
      macroTBody.html('')


      debug && console.log("actionType currentLookup: ", currentLookup)

      
      let firstVal = null
      debug && console.log("making request to endpoint: ", endpoint, lookup.filter)
      updateMatchTH()
      if(endpoint == 'text'){
        // reset query select and hide it and show query text
        // hide actionQuerySelect, show actionQueryText
        actionQuerySelect.hide()
        const actionQueryText = $('#actionQueryText')
        actionQueryText.show()
        checkSensitiveWrapper.show()
        checkSensitiveWrapperLabel.removeClass('is-hidden')
      }else if(endpoint == 'custom'){
        // DRY maybe functionalize if repeated often exactly
        actionQuerySelect.show()
        actionQueryText.hide()
        checkSensitiveWrapper.hide()
        checkSensitiveWrapperLabel.addClass('is-hidden')
        actionQuerySelect.find('option').remove()
        debug && console.log("custom field lookup: ", lookup)

        if(lookup.type == 'checkbox'){
          actionQuerySelect.append('<option>true</option>')
          actionQuerySelect.append('<option>false</option>')
        }
        else{
          lookup.custom_field_options.forEach(item=>{
            actionQuerySelect.append(`<option>${item.value}</option>`)
          })
        }
        actionQuerySelect.val($("#actionQueryValue option:first").val()).change();
      }else if(endpoint == 'hardcoded'){
        actionQuerySelect.show()
        actionQueryText.hide()
        checkSensitiveWrapper.hide()
        checkSensitiveWrapperLabel.addClass('is-hidden')
        actionQuerySelect.find('option').remove()
        debug && console.log("doing a switch on lookup: ", lookupKey)
        switch(lookupKey){
          case 'Priority':
            actionQuerySelect.append('<option>urgent</option>')
            actionQuerySelect.append('<option>high</option>')
            actionQuerySelect.append('<option>normal</option>')
            actionQuerySelect.append('<option>low</option>')
            firstVal = 'urgent'
            break
          case 'Comment Mode':
            actionQuerySelect.append('<option value="true">Public</option>')
            actionQuerySelect.append('<option value="false">Private</option>')
            firstVal = 'true'
            break
          case 'Status':
            actionQuerySelect.append('<option>open</option>')
            actionQuerySelect.append('<option>pending</option>')
            actionQuerySelect.append('<option>solved</option>')
            firstVal = 'open'
            break
          case 'Type':
            actionQuerySelect.append('<option>question</option>')
            actionQuerySelect.append('<option>incident</option>')
            actionQuerySelect.append('<option>problem</option>')
            actionQuerySelect.append('<option>task</option>')
            firstVal = 'question'
            break
          case 'Active':
            actionQuerySelect.append('<option value="true">True</option>')
            actionQuerySelect.append('<option value="false">False</option>')
            break
        }
        // actionQuerySelect.val(firstVal).change()


        // actionQuerySelect.val("#actionQueryValue option:first").val().change();
        actionQuerySelect.val($("#actionQueryValue option:first").val()).change();


        debug && console.log("appending to actionQuerySelect")
      }else{
        genericAPIReq(endpoint, lookup.filter)
        .then(data=>{
          debug && console.log("data from api request: ", endpoint)
          const dataList = data[lookup.api]
          debug && console.log("data to loop: ", dataList)
          actionQuerySelect.show()
          actionQueryText.hide()
          checkSensitiveWrapper.hide()
          debug && console.log("resetting actionQueryValue options")
          actionQuerySelect.find('option').remove()
          dataList.forEach(item=>{
            debug && console.log("Info: in data list foreach")
            if(!firstVal){
              firstVal = item.id
              debug && console.log("firstVal set to: ", firstVal)
            }
            // add it to the choice select
            actionQuerySelect.append('<option value='+item.id+'>'+item[lookup.title]+'</option>')
            debug && console.log("Info: end of data list foreach")
          })
          // actionQuerySelect.val(firstVal).change()
          actionQuerySelect.val($("#actionQueryValue option:first").val()).change();
        })
      }


      // hit server to populate the search drop down
    })

    // populates the replaceSelectValue drop down
    replaceType.change(function(){
      // reset replace UI for 2 deep options
      groupTagWrapper.hide()


      debug && console.log("replaceType chosen, populating replacement values")
      lookupKey = $(this).val()
      lookup = lookups[$(this).val()]
      replaceLookup = lookup
      // currentLookup = $(this).val()
      const endpoint = lookup.api
      debug && console.log("making request to endpoint: ", endpoint, lookup.filter)
      // debug && console.log("currentLookup = ", currentLookup)
      if(endpoint == 'text'){
        // reset query select and hide it and show query text
        replaceSelectValue.hide()
        const replacdeText = $('#replaceText')
        replaceText.show()
        disableReplaceText(false)
        checkReplaceWordWrapper.show()
        checkReplaceWordWrapperLabel.removeClass('is-hidden')
      }else if(endpoint == 'custom'){
        replaceSelectValue.show()
        replaceText.hide()
        checkReplaceWordWrapper.hide()
        checkReplaceWordWrapperLabel.addClass('is-hidden')
        replaceWordWrapper.hide()
        isReplaceWord = false // disable replaceword
        // replaceText.prop('disable', false)
        disableReplaceText(false)
        replaceSelectValue.find('option').remove()

        if(lookup.type == 'checkbox'){
          replaceSelectValue.append('<option>true</option>')
          replaceSelectValue.append('<option>false</option>')
        }
        else{
          lookup.custom_field_options.forEach(item=>{
            replaceSelectValue.append(`<option>${item.value}</option>`)
          })
        }

      }else if(endpoint == 'hardcoded'){
        replaceSelectValue.show()
        replaceText.hide()
        checkReplaceWordWrapper.hide()
        checkReplaceWordWrapperLabel.addClass('is-hidden')
        replaceWordWrapper.hide()
        isReplaceWord = false // disable replaceword
        // replaceText.prop('disable', false)
        disableReplaceText(false)
        replaceSelectValue.find('option').remove()
        debug && console.log("doing a switch on lookup: ", lookupKey)
        // DRY this needs to be functionalized
        switch(lookupKey){
          case 'Group Permission':
            replaceSelectValue.append('<option>All</option>')
            replaceSelectValue.append('<option>Choose Groups</option>')
            break
          case 'Priority':
            replaceSelectValue.append('<option>urgent</option>')
            replaceSelectValue.append('<option>high</option>')
            replaceSelectValue.append('<option>normal</option>')
            replaceSelectValue.append('<option>low</option>')
            break
          case 'Comment Mode':
            replaceSelectValue.append('<option value="true">Public</option>')
            replaceSelectValue.append('<option value="false">Private</option>')
            break
          case 'Status':
            replaceSelectValue.append('<option>open</option>')
            replaceSelectValue.append('<option>pending</option>')
            replaceSelectValue.append('<option>solved</option>')
            break
          case 'Type':
            replaceSelectValue.append('<option>question</option>')
            replaceSelectValue.append('<option>incident</option>')
            replaceSelectValue.append('<option>problem</option>')
            replaceSelectValue.append('<option>task</option>')
            break
          case 'Active':
            replaceSelectValue.append('<option value="true">True</option>')
            replaceSelectValue.append('<option value="false">False</option>')
            break
        }
        debug && console.log("appending to replaceSelectValue")
      }else{
        genericAPIReq(endpoint, lookup.filter)
        .then(data=>{
          debug && console.log("data from api request: ", endpoint)
          const dataList = data[lookup.api]
          debug && console.log("data to loop: ", dataList)
          replaceSelectValue.show()
          replaceText.hide()
          checkReplaceWordWrapper.hide()
          replaceWordWrapper.hide()
          isReplaceWord = false // disable replaceword
          replaceText.prop('disable', false)
          debug && console.log("resetting replaceSelectValue options")
          replaceSelectValue.find('option').remove()
          dataList.forEach(item=>{
            debug && console.log("Info: in data list foreach")
            // add it to the choice select
            replaceSelectValue.append('<option value='+item.id+'>'+item[lookup.title]+'</option>')
            debug && console.log("Info: end of data list foreach")
          })
        })
      }
    })

    // adds custom ticket fields
    function addTypeChoices(){
      debug && console.log("Adding custom ticket fields to drop down", allCustomTicketFields)
      allCustomTicketFields.forEach(item=>{
        debug && console.log("adding field: ", item.title)
        actionType.append(`<option value='custom_fields_${item.id}'>Custom: ${item.title}</option>`)
        replaceType.append(`<option value='custom_fields_${item.id}'>Custom: ${item.title}</option>`)
      })
    }

              
    function updateLookupWithCustomFields(){
      allCustomTicketFields.forEach(item=>{
        item.api = 'custom'
        lookups['custom_fields_' + item.id] = item
        lookups['custom_fields_' + item.id].id = 'custom_fields_'+item.id
      })
      debug && console.log("lookups updated: ", lookups)
    }

    function filterMacros(key, value, isText){
      debug && console.log("------")
      debug && console.log("inside of filterMacros")
      debug && console.log(`Matches for key(field): ${key} with value ${value}`)
      const matchedMacros = []
      const tempMacros = allMacros.slice()
      tempMacros.forEach(macro=>{
        let match = false
        if(key == 'title' || key == 'description'){
          if(macro[key] && checkMatchStr(macro[key], value)){ 
            // if(macro[key] && macro[key].toLowerCase().indexOf(value) != -1){ // old non case sensitive
            debug && console.log(`this macro ${key} matches: `, macro)
            match = true
            macro.matchedField = macro[key]
          }
        }else if(key == 'active'){
          if(String(macro.active) == value){
            match = true
            macro.matchedField = macro.description
          }
        }else{
          macro.actions.forEach(action=>{
            // debug && console.log(`comparing:${key} to ${action.field} to${action.value} to ${value}`)
            if(isText){
              // value = value.toLowerCase() // used if no case-sensitive toggle
              // if(action.field == key && action.value.toLowerCase().indexOf(value) != -1){
              if(action.field == key && checkMatchStr(action.value, value)){
                debug && console.log("this action matches: ", action)
                match = true
                macro.matchedField = action.value
              // }else if(key == 'comment_value_html' && action.value.toLowerCase().indexOf(value) != -1){
              }else if(action.field == 'comment_value' && key == 'comment_value_html' && checkMatchStr(action.value, value)){
                // special case for comment_value and comment_value_html - this checks comment_value
                debug && console.log("this action matches: ", action)
                match = true
                macro.matchedField = action.value
              }else{
                // debug && console.log("this action NO DOES NOT matches: ", action)
              }
            }else{
              if(action.field == key && action.value == value){
                debug && console.log("this action matches: ", action)
                match = true
                macro.matchedField = action.value
              }else{
                // debug && console.log("this action NO DOES NOT matches: ", action)
              }
            }
          })
        }
        if(match){
          matchedMacros.push(macro)
        }
      })
      return matchedMacros
    }


    function updateMacroStatusNew(macro, macros, status){
      debug && console.log("inside updateMacroStatus")
      const prefixID = 'macro-result-'
      const statusImages = {
        'unsent':"https://img.icons8.com/color/16/000000/sort-right.png",
        'sending':"https://img.icons8.com/color/16/000000/synchronize.png",
        'success':"https://img.icons8.com/color/16/000000/ok.png",
      }

      if(macro){
        // find the macro line
        debug && console.log("updating status for macro: ", macro)
        const toUpdateDiv = $('#'+prefixID+macro.listPos)
        debug && console.log("going to update: ", toUpdateDiv)

        // update the img with correct status image
        const tdToUpdate = $(toUpdateDiv.find('td')[0])
        debug && console.log("tdToUpdate", tdToUpdate)
        const statusImage = $(tdToUpdate.find('img')[0])
        debug && console.log("image to update", statusImage)
        statusImage.attr('src', statusImages[status])
        debug && console.log("image to update", statusImage)
        // macroStatusTD.append('<img src="https://img.icons8.com/color/16/000000/synchronize.png">')
        // const tempWrapper = $('<div />')
        // const tempElem = jQuery('<h3 />').text('Title: '+macro.title)
        // tempWrapper.attr('id', 'macro-result-' + macro.listPos)
        // const tempCheckbox = $('<span />').text(status)
        // update a single macro status
      }else if(macros){
        // NOTE: currently this is initial only, does not support update
        // update all macro status usually for initial
        // reset #results
        debug && console.log("inside macros updateMacroStatus")
        const macroTBody = $($('#macro-results').find('tbody')[0])
        debug && console.log("Should be the tbody, resetting it", macroTBody)
        macroTBody.html('')
        macros.forEach(macro=>{
          debug && console.log("updating a macro result status at: ", macro.listPos)
          debug && console.log("updating a macro result status at: ", macro.title)
          const macroTR = $('<tr />')


          macroTR.addClass('c-table__row')
          macroTR.attr('id', prefixID + macro.listPos)

          const macroStatusTD = $('<td />')
          macroStatusTD.addClass('td-vert')
          // macroStatusTD.append('<img src="https://img.icons8.com/color/16/000000/ok.png" />')
          // unsent
          // macroStatusTD.append('<img src="https://img.icons8.com/color/16/000000/synchronize.png">')
          macroStatusTD.append('<img src="https://img.icons8.com/color/16/000000/sort-right.png" />')
          // ok
          // macroStatusTD.append('<img src="https://img.icons8.com/color/16/000000/ok.png" />')

          const macroCheckTD = $('<td />')
          macroCheckTD.addClass('c-table__row__cell')

          const checkDiv = $('<td />')
          checkDiv.addClass('c-chk')

          const checkInput = $('<input />')
          checkInput.addClass('c-chk__input')
          checkInput.attr('id', 'macro-input-'+macro.listPos)
          checkInput.attr('type', 'checkbox')
          checkInput.attr('name', 'macro-match[]')
          checkInput.val(macro.listPos)


          const checkLabel = $('<label />')
          checkLabel.addClass('c-chk__label is-hidden chk-offset')
          checkLabel.attr('for', 'macro-input-'+macro.listPos)

          const macroDescTD = $('<td />').html(macro.title)
          macroDescTD.addClass('c-table__row__cell')
        
          // const matchText = macro.matchedField

          const macroMatchTD = $('<td />').html(macro.matchedField)
          macroMatchTD.addClass('c-table__row__cell')

          const macroLinkTD = $('<td />').html('<a href="https://'+subdomain+'.zendesk.com/agent/admin/macros/'+macro.id+'" target="_blank">View Macro</a>')
          macroLinkTD.addClass('c-table__row__cell')

          debug && console.log("adding stuff to checkdiv")
          checkDiv.append(checkInput)
          checkDiv.append(checkLabel)

          macroCheckTD.append(checkDiv)

          macroTR.append(macroStatusTD)
          macroTR.append(macroCheckTD)
          macroTR.append(macroDescTD)
          macroTR.append(macroMatchTD)
          macroTR.append(macroLinkTD)

          // tr(class="c-table__row")
          //   td(class="c-table__row__cell")
          //     div(class="c-chk")
          //       input(class="c-chk__input",
          //         id="chk-0.0.1", 
          //           type="checkbox")
          //       label(class="c-chk__label is-hidden",
          //         for="chk-0.0.1")
          //   td(class="c-table__row__cell") filler cell text


          debug && console.log("adding stuff to macroTR")
          macroTBody.append(macroTR)
        })
        // add all with an id of macro-result-i
        

      }
    }

    // debug && console.log("running filterMacros")
    // filterMacros('test', 'one', true)
    // debug && console.log("running filterMacros")

    actionQuerySelect.change(function(event){
      // pull down from db then filter
      const selectedVal = actionQuerySelect.val()
      debug && console.log("selectedVal: ", selectedVal)
      debug && console.log("actionQuerySelect currentLookup: ", currentLookup)
      const tempLookupID = lookups[currentLookup].id
      debug && console.log("actionQuerySelect tempLookupID: ", tempLookupID)
      // const matchedMacros = filterMacros(lookups[currentLookup].id, selectedVal, false)
      // debug && console.log("selectedVal: ", selectedVal)
      // debug && console.log("matchedMacros: ", matchedMacros)
      // displayItems(matchedMacros, 'title', '#results', true)
      // resultMacros = filterMacros(currentLookup.toLowerCase(), selectedVal, true)
      resultMacros = filterMacros(tempLookupID, selectedVal, true)
      debug && console.log("filtered macros: ", resultMacros)
      for(i = 0; i < resultMacros.length; i++){
        resultMacros[i].listPos = i
        resultMacros[i].updateStatus = 'unsent'
      }
      debug && console.log("actionquery select calling updateMacroStatus")
      updateMacroStatusNew(null, resultMacros, 'unsent')
      debug && console.log("after updateMacroStatus")
    })


    actionQueryText.keyup(function(){
      if(event.which == 13){
        event.preventDefault()
      }
      
      // pull down from db then filter based on text
      const selectedVal = actionQueryText.val()
      debug && console.log("selectedText: ", selectedVal)
      debug && console.log("actionQueryText currentLookup: ", currentLookup)
      const tempLookupID = lookups[currentLookup].id
      debug && console.log("actionQuerySelect tempLookupID: ", tempLookupID)
      // resultMacros = filterMacros(currentLookup.toLowerCase(), selectedVal, true)
      resultMacros = filterMacros(tempLookupID, selectedVal, true)
      debug && console.log("filtered macros: ", resultMacros)
      for(i = 0; i < resultMacros.length; i++){
        resultMacros[i].listPos = i
        resultMacros[i].updateStatus = 'unsent'
      }
      debug && console.log("calling updateMacroStatus")
      updateMacroStatusNew(null, resultMacros, 'unsent')
      debug && console.log("after updateMacroStatus")

      // make dummy request to server
      if(resultMacros.length > 0){
        // const requestURL = 'macros/'+tempMacros[0].id        
        // const requestURL = 'macros/update_many'       
        // debug && console.log("making demo PUT request to: ", requestURL)
        // debug && console.log("payload: ", {macro:{title:'New Updated Via API'}})
        // const macroPayload = bulkMacroPayloadBuilder(tempMacros.slice())
        // genericAPIReqPut(requestURL, {macro:tempMacros[0]})
        // genericAPIReqPut(requestURL, {macro:{title:'New Updated Via API'}})
        // debug && console.log("updating macros with macroPayload: ", macroPayload)
        // genericAPIReqPut(requestURL, macroPayload)
        // the update_many endpoint doesn't support changing many fields
        // genericAPIReqPut(requestURL, {macros:[{id:360074290434, title:"New Testing Macro udpated via API"}]})
        // send X API requests at a time
        // disable send requests for now
        // debug && console.log("calling sendManyAPIRequests")
        // sendManyAPIRequests(resultMacros)
      }
    })

    checkAll.change(function(){
      debug && console.log("check all clicked, eventually check/uncheck all checkboxes")
      debug && console.log("check all .is(:checked) ", checkAll.is(':checked'))
      // if(checkAll.is(':checked')){
      resultMacros.forEach(macro=>{
        // set the value to checked or unchecked
        const toUpdateDiv = $('#'+prefixID+macro.listPos)
        debug && console.log("going to update: ", toUpdateDiv)
        const tdToUpdate = $(toUpdateDiv.find('td')[1]) // future version maybe not needed
        debug && console.log("tdToUpdate", tdToUpdate)
        const tempCheckbox = $(tdToUpdate.find('input')[0]) 
        debug && console.log("input.checkbox to update", tempCheckbox)
        tempCheckbox.prop('checked', checkAll.is(':checked'))
        debug && console.log("tempCheckbox .is(:checked) ", tempCheckbox.is(':checked'))
        // statusImage.attr('src', statusImages[status])
        // const temp
      })
      // }
    })
    checkCaseSensitive.change(function(){
      isCaseSensitive = !isCaseSensitive
      debug && console.log("updated case sensitive", isCaseSensitive)
      actionQueryText.trigger('keyup')
    })

    checkReplaceWord.change(function(){
      isReplaceWord = !isReplaceWord
      // debug && console.log("actionquerytext trigger")
      // actionQueryText.trigger('change')
      debug && console.log("replace word wrapper show ")
      // actionQueryText.trigger('keyup')
      if(replaceWordWrapper.is(':visible')){
        debug && console.log("hiding replace word")
        replaceWordWrapper.hide()
        // replaceText.prop('disable', false)
        disableReplaceText(false)
      }else{
        debug && console.log("showing replace word")
        replaceWordWrapper.show()
        disableReplaceText(true)
        // replaceText.prop('disable', true)
      }
      // debug && console.log("actionquerytext dispatch event")
      // actionQueryText.dispatchEvent(new Event('change'))
    })

    updateButton.click(function(){
      debug && console.log("update button clicked")
      // find out which macros are selected send them to udpate
      const checkboxes = []
      const macrosToUpdate = []
      $('#macro-results tbody').find(':checkbox:checked').each(function(){
        const macroPos = $(this).val()
        debug && console.log("this is checked: ", $(this).val())
        updateMacroStatusNew(resultMacros[macroPos], null, 'sending') // result macros from last filter
        // send actual update
        macrosToUpdate.push(resultMacros[$(this).val()])
      }) 
      debug && console.log($('macro-results').find('input'))
      // debug && console.log($('macro-results'))
      debug && console.log("done checking checkboxes, sending update request")
      debug && console.log("lookup field to update: ", lookup)
      debug && console.log("lookup field to update: ", lookup)
      // const localUpdatedMacros = macroUpdaterLocal(macrosToUpdate, lookup.id, lookup.meta) 
      const localUpdatedMacros = macroUpdaterLocal(macrosToUpdate, replaceLookup.id, replaceLookup.meta) 
      debug && console.log("updated local macros: ", localUpdatedMacros)

      alert('test')
      // return early if error
      if(localUpdatedMacros.error){
        return alert('Error: ', localUpdatedMacros.error)
      }

      // update macros on zendesk
      sendManyAPIRequests(localUpdatedMacros)
    })

    function testFunction(){
      debug && console.log("inside test function")
    }
 
    // replace field w/ value
    function macroUpdaterLocal(macros, field, metaBool){
      debug && console.log(`field: ${field}, metaBool: ${metaBool}`)
      // find out if its text or a drop down field
      
      // replaceSelectValue = $('#replaceSelectValue')
      // replaceText = $('#replaceText')
      let tempValue = null

      // check special case then drop down or text
      if(field == 'group_permissions'){

        // check if all or groups
        tempValue = replaceSelectValue.val()
        if(tempValue != 'All'){
          // check that at least one group has been added
          debug && console.log("groupTagList.children(): ", groupTagList.children())
          if(groupTagList.children().length == 0){
            return {error:'Please select at least one group'}
          }
          tempValue = []
          groupTagList.children().each(function(){
            const tempChild = $(this)
            tempValue.push(tempChild.attr('data1'))
          })
        }
      }else if(replaceSelectValue.is(':visible')){
        debug && console.log("use the drop down value")
        tempValue = replaceSelectValue.val()
      }else{
        debug && console.log("use the text value")
        tempValue = replaceText.val()
      }
      debug && console.log(`replace value: ${tempValue} with lookup.id ${lookup.id}`)
      const newMacros = macros.slice()
      debug && console.log("newMacros: ", newMacros)

      newMacros.forEach(macro=>{
        // non field updates
        if(field == 'group_permissions'){
          // update restriction id and ids for group permissions
          if(tempValue == 'All'){
            macro.restriction = null
          }else{
            let firstVal = null
            tempValue.forEach(tempV=>{
              if(!firstVal){
                macro.restriction = {}
                debug && console.log('restriction  type set to group')
                macro.restriction = {id:parseInt(tempV), ids:[]}
                macro.restriction.type = 'Group'
                firstVal = 'done'
              }
              macro.restriction.ids.push(parseInt(tempV))
            })
          }
        }else if(lookup.meta){
          // meta fields title, active, description
          if(isReplaceWord && (lookup.metaField == 'title' || lookup.metaField == 'description')){
            macro[lookup.metaField] = replaceWordInstances(macro[lookup.metaField], replaceWordNew.val())
          }else{
            macro[lookup.metaField] = tempValue
          }
          debug && console.log(`${macro[lookup.metaField]} set to ${tempValue}`)
        }else{
          // search for the field in actions
          let found = false
          macro.actions.forEach(action=>{
            // check if just replacing word instances
            if(isReplaceWord){
              if(action.field == field){
                found = true
                // action.value = tempValue
                action.value = replaceWordInstances(action.value, replaceWordNew.val())
              }else if(action.field == 'comment_value' && field == 'comment_value_html'){
                // special case for comments that can be 2 fields
                found = true
                action.value = replaceWordInstances(action.value, replaceWordNew.val())
                // action.value = tempValue
              }
            }else{
              if(action.field == field){
                found = true
                action.value = tempValue
              }else if(action.field == 'comment_value' && field == 'comment_value_html'){
                // special case for comments that can be 2 fields
                found = true
                action.value = tempValue
              }
            }
          })
          if(!found){
            // insert it
            macro.actions.push({field, tempValue})
          }
        }
      })
      return newMacros
    }

    function updateMatchTH(){
      // update matched column name
      const matchTH = $('#macro-results-match-th')
      debug && console.log("going to update: ", matchTH)
      matchTH.html('Matched '+currentLookup)
    }

    // build payload for PUT to zendesk to update macros bulk
    function bulkMacroPayloadBuilder(matchedMacros){
      const macroPayload = {macros:[]}
      matchedMacros.forEach(macro=>{
        macro.title += 'updated via API'
        debug && console.log("adding macro to macroPayload: ", macro)
        macroPayload.macros.push(macro)
      })
      return macroPayload
    }

    function disableReplaceText(bool){
      if(bool){
        // replaceText.addClass('c-txt__input.is_disabled c-txt__input[disabled]')
        // replaceText.addClass('is_disabled')
        replaceText.prop('disabled', true)
      }else{
        // replaceText.removeClass('is_disabled')
        replaceText.prop('disabled', false)
        // replaceText.removeClass('c-txt__input.is_disabled c-txt__input[disabled]')
      }
      // set class
      // replaceType.addClass()
      // set disabled
    }

    // utility code
    function checkMatchStr(big, sub){
      debug && console.log(`comparing big:${big} to sub:${sub} isCaseSensitive`, isCaseSensitive)
      let match = false
      if(isCaseSensitive){
        if(big.indexOf(sub) != -1){
          match = true
        }

      }else{
        sub = sub.toLowerCase()
        big = big.toLowerCase()
        if(big.indexOf(sub) != -1){
          match = true
        }
      }
      return match

    }

    function replaceWordInstances(fieldValue){
      debug && console.log("original field value: ", fieldValue)
      debug && console.log("replaceWordOriginal: ", replaceWordOriginal.val())
      const regex = new RegExp(replaceWordOriginal.val(), 'g')
      const newValue = fieldValue.replace(regex, replaceWordNew.val())
      debug && console.log("new field value: ", newValue)
      return newValue
    }


    const groupTagInput = $('#groupTagInput')	

    // disable enter event for now
    // groupTagInput.on('keydown', function(event){
    //   debug && console.log(event.type + ": " +  event.which)
    //   if(event.which == 13){
    //     debug && console.log("preventing default")
    //     event.preventDefault()
    //     const tag = groupTagInput.val().trim()
    //     addTag(tag, true)
    //     groupTagInput.val('')
    //     return false
    //   }
    //   // add caret functionality for tags
    //   // if(event.which == 8 && groupTagInput.caret() == 0){
    //   //   // debug && console.log("The cursor position is: ", newTagInput.caret())
    //   //   removeLastTag()

    //   // }
    // })

    function closeTag(e){
      const elem = jQuery(this)
      debug && console.log("Removing tag: ", elem.text())
      elem.remove()
    }

    // group
    replaceSelectValue.change(function(){
      const selectedVal = replaceSelectValue.val()
      debug && console.log("replace select value changed: ", selectedVal)
      if(selectedVal == 'Choose Groups'){
        // show group permissions extra fields
        groupTagWrapper.show()
      }else{
        // hide group permission extra fields
        groupTagWrapper.hide()
      }
      
    })
    
    // add tag if group doesn't exist	
    function addTag(tag, dataValue, userEntered=false){
      const tempTag = jQuery('<div/>').attr('class', 'c-tag c-tag--light groupTag')
      tempTag.attr('data1', dataValue)
      let exists = false
      debug && console.log("Searching to see if tag exists: ", tag)
      // updated to inline
      groupTagList.children().each(function(index){
        debug && console.log("current group compare tag: ", jQuery(this).text())
        if(jQuery(this).text() == tag)
          exists = true
      })
      // check dupes
      if(!exists){
        debug && console.log("Adding new tag")
        tempTag.append(`<span>${tag}<span class='closeTag'></span></span>`)
        debug && console.log("appending: tempTag", tempTag)
        jQuery('#groupTagList').append(tempTag)
        jQuery('.closeTag').parent().parent().click(closeTag)
      }
      // clear input	
      $('#groupTagInput').val('')
    }

    const replaceDynamicWordWrapper = $('#replaceDynamicWordWrapper')
    const checkDynamicSensitiveWrapper= $('#checkDynamicSensitiveWrapper')
    const checkDynamicSensitiveWrapperLabel= $('#checkDynamicSensitiveWrapperLabel')
    const checkDynamicReplaceWordWrapper= $('#checkDynamicReplaceWordWrapper')
    const dynamicCheckAll = $('#dynamic-check-all')
    const prefixDynamicID = 'dynamic-result-'


    // const dynamicQueryText = $('#dynamicQueryText')

    const dynamicType = $('#dynamicType')
    const dynamicQueryText = $('#dynamicQueryText')
    const checkDynamicCaseSensitive = $('#checkDynamicCaseSensitive')

    replaceDynamicWordWrapper.hide()
    
    let resultDynamicItems = []
    let isDynamicTitle = true

    // Dynamic Content js
    function getAllDynamicContentAPI(){
      return new Promise((resolve, reject)=>{
        const dynamicContentReq = {
            url: '/api/v2/dynamic_content/items.json',
            type: 'GET',
            dataType: 'json'
        }
        client.request(dynamicContentReq)
        .then(data=>{
          debug && console.log("got the data from dynamicContent API")
          debug && console.log(data)
          resolve(data)
        })
      })
    }

    // still needs DRY pass with actionQueryText, some similar logic
    dynamicQueryText.keyup(function(){
      if(event.which == 13){
        event.preventDefault()
      }
      
      // pull down from db then filter based on text
      const selectedVal = dynamicQueryText.val()
      debug && console.log("selectedText: ", selectedVal)
      // const tempLookupID = lookups[currentLookup].id
      const tempLookupID = 'not used in dynamic content yet'
      resultDynamicItems = filterDynamicItems(tempLookupID, selectedVal, isDynamicTitle)
      debug && console.log("filtered macros: ", resultMacros)
      for(i = 0; i < resultMacros.length; i++){
        resultDynamicItems[i].listPos = i
        resultDynamicItems[i].updateStatus = 'unsent'
      }
      debug && console.log("resultDynamicItems: ", resultDynamicItems)
      // implement updateDynamicStatus to add to results
      // debug && console.log("calling updateMacroStatus")
      updateStatusNew(null, resultDynamicItems, 'unsent', 'dynamic')
      debug && console.log("after updateStatusNew")
      return // return early for now

      // make dummy request to server
      if(resultMacros.length > 0){
        // const requestURL = 'macros/'+tempMacros[0].id        
        // const requestURL = 'macros/update_many'       
        // debug && console.log("making demo PUT request to: ", requestURL)
        // debug && console.log("payload: ", {macro:{title:'New Updated Via API'}})
        // const macroPayload = bulkMacroPayloadBuilder(tempMacros.slice())
        // genericAPIReqPut(requestURL, {macro:tempMacros[0]})
        // genericAPIReqPut(requestURL, {macro:{title:'New Updated Via API'}})
        // debug && console.log("updating macros with macroPayload: ", macroPayload)
        // genericAPIReqPut(requestURL, macroPayload)
        // the update_many endpoint doesn't support changing many fields
        // genericAPIReqPut(requestURL, {macros:[{id:360074290434, title:"New Testing Macro udpated via API"}]})
        // send X API requests at a time
        // disable send requests for now
        // debug && console.log("calling sendManyAPIRequests")
        // sendManyAPIRequests(resultMacros)
      }
    })

    // set the isDynamicTitle to true or false
    dynamicType.change(function(){
      const val = dynamicType.val().toLowerCase()
      if(val == 'variant')
        isDynamicTitle = false
      else
        isDynamicTitle = true
      debug && console.log("isDynamicTitle is now: ", isDynamicTitle)
    })

    // need to update/create dynamic status update function first
    dynamicCheckAll.change(function(){
      debug && console.log("check all clicked, eventually check/uncheck all checkboxes")
      debug && console.log("check all .is(:checked) ", checkAll.is(':checked'))
      // if(checkAll.is(':checked')){
      resultDynamicItems.forEach(item=>{
        // set the value to checked or unchecked
        const toUpdateDiv = $('#'+prefixID+item.listPos)
        debug && console.log("dynamic content status going to update: ", toUpdateDiv)
        const tdToUpdate = $(toUpdateDiv.find('td')[1]) // future version maybe not needed
        debug && console.log("tdToUpdate", tdToUpdate)
        const tempCheckbox = $(tdToUpdate.find('input')[0]) 
        debug && console.log("input.checkbox to update", tempCheckbox)
        tempCheckbox.prop('checked', checkAll.is(':checked'))
        debug && console.log("tempCheckbox .is(:checked) ", tempCheckbox.is(':checked'))
        // statusImage.attr('src', statusImages[status])
        // const temp
      })
      // }
    })

    // need to have title and variant be searchable, key currently not used
    // currently returns a list of variants with added itemID and itemName 
    function filterDynamicItems(key, value, isTitle){
      debug && console.log("------")
      debug && console.log("inside of filterDynamicItems")
      debug && console.log(`Matches for key(isTitle): ${isTitle} with value ${value}`)
      const matchedVariants = []
      const tempItems = allDynamicItems.slice()
      // case 1 match title - return matched items contained variants (some items, all variants)
      // case 2 match variant text - returned matched variants - but group by item (some items, some variants)
      tempItems.forEach(item=>{
        let match = false
        // const matchedVariants = [] // used for non title search
        // if(key == 'title'){
        if(isTitle){
          // if(item.name.toLowerCase().indexOf(value) != -1){ //old code non case sensitive
          // updated to check for case sensitive
          if(checkMatchStr(item.name, value)){ 
            debug && console.log("this dynamic item name matches: ",  item)
            match = true
            // item.matchedField = item.name
            // insert all varaints into matched items
            item.variants.forEach(variant=>{
              variant.itemName = item.name
              variant.itemID = item.id
              debug && console.log("adding variant: ", variant)
              matchedVariants.push(variant)
            })
          }
        }else{
          item.variants.forEach(variant=>{
            if(checkMatchStr(variant.content, value)){
              debug && console.log("this variant matches: ", variant)
              match = true
              variant.itemName = item.name
              variant.itemID = item.id
              debug && console.log("adding variant: ", variant)
              matchedVariants.push(variant)
            }
          })
        }
        // if(match && isTitle){
        //   matchedItems.push(item)
        // }else if(match){
        //   item.variants = matchedVariants.slice()
        //   matchedItems.push(item)
        // }
      })
      debug && console.log("matchedVariantItems: ", matchedVariants)
      return matchedVariants
    }

    // should support macro or dynamic item
    function updateStatusNew(item, items, status, type){
      debug && console.log("inside updateStatusNew, type:", type)
      const prefixID = (type=='macro') ? 'macro-result-': 'dynamic-result-'
      const statusImages = {
        'unsent':"https://img.icons8.com/color/16/000000/sort-right.png",
        'sending':"https://img.icons8.com/color/16/000000/synchronize.png",
        'success':"https://img.icons8.com/color/16/000000/ok.png",
      }

      if(item){
        // find the item line
        // debug && console.log("updating status for item: ", item)
        debug && console.log(`updating status for type: ${type} item: ${item}`)
        const toUpdateDiv = $('#'+prefixID+item.listPos)
        debug && console.log("going to update: ", toUpdateDiv)

        // update the img with correct status image
        const tdToUpdate = $(toUpdateDiv.find('td')[0])
        debug && console.log("tdToUpdate", tdToUpdate)
        const statusImage = $(tdToUpdate.find('img')[0])
        debug && console.log("image to update", statusImage)
        statusImage.attr('src', statusImages[status])
        debug && console.log("image to update", statusImage)
      }else if(items){
        // NOTE: currently this is initial only, does not support update
        // update all item statuses usually for initial
        // reset #results
        const itemTBody = (type=='macro') ? $($('#macro-results').find('tbody')[0]):$($('#dynamic-results').find('tbody')[0])
        debug && console.log("Should be the tbody, resetting it", itemTBody)
        itemTBody.html('')
        items.forEach(item=>{
          debug && console.log("updating a item result status at: ", item.listPos)
          const itemTR = $('<tr />')


          itemTR.addClass('c-table__row')
          itemTR.attr('id', prefixID + item.listPos)

          const itemStatusTD = $('<td />')
          itemStatusTD.addClass('td-vert')
          // unsent
          itemStatusTD.append('<img src="https://img.icons8.com/color/16/000000/sort-right.png" />')

          const itemCheckTD = $('<td />')
          itemCheckTD.addClass('c-table__row__cell')

          const checkDiv = $('<td />')
          checkDiv.addClass('c-chk')

          const itemCheckInput = (type == 'macro') ? 'macro-input': 'dynamic-input'
          const itemCheckMatch = (type == 'macro') ? 'macro-match[]': 'dynamic-match[]'

          const checkInput = $('<input />')
          checkInput.addClass('c-chk__input')
          checkInput.attr('id', itemCheckInput+'-'+item.listPos)
          checkInput.attr('type', 'checkbox')
          checkInput.attr('name', itemCheckMatch)
          checkInput.val(item.listPos)


          const checkLabel = $('<label />')
          checkLabel.addClass('c-chk__label is-hidden chk-offset')
          checkLabel.attr('for', itemCheckInput+'-'+item.listPos)

          const itemTitleText = (type=='macro')? item.title : item.itemName
          const itemDescTD = $('<td />').html(itemTitleText)
          itemDescTD.addClass('c-table__row__cell')
        
          // const matchText = macro.matchedField
          if(!item.matchedField){
            // most likely dynamic item not using them yet
            item.matchedField = item.content
          }


          const itemMatchTD = $('<td />').html(item.matchedField)
          itemMatchTD.addClass('c-table__row__cell')
          const linkText = (type == 'macro') ? 'Macro' : 'Dynamic Content'
          const linkHref = (type == 'macro') ? 'agent/admin/macros' : 'dynamic_content/items'
          const linkID = (type == 'macro') ? item.id : item.itemID

          const itemLinkTD = $('<td />').html('<a href="https://'+subdomain+'.zendesk.com/'+linkHref+'/'+linkID+'" target="_blank">View '+linkText+'</a>')
          itemLinkTD.addClass('c-table__row__cell')


          debug && console.log("adding stuff to checkdiv")
          checkDiv.append(checkInput)
          checkDiv.append(checkLabel)

          itemCheckTD.append(checkDiv)

          itemTR.append(itemStatusTD)
          itemTR.append(itemCheckTD)
          itemTR.append(itemDescTD)
          itemTR.append(itemMatchTD)
          itemTR.append(itemLinkTD)

          // add variant fields
          if(type=='dynamic'){
            const itemVariantLinkTD = $('<td />').html('<a href="https://'+subdomain+'.zendesk.com/'+linkHref+'/'+item.itemID+'/variants/'+item.id+'" target="_blank">View Variant</a>')
            itemLinkTD.addClass('c-table__row__cell')

            itemTR.append(itemVariantLinkTD)
          }

          // tr(class="c-table__row")
          //   td(class="c-table__row__cell")
          //     div(class="c-chk")
          //       input(class="c-chk__input",
          //         id="chk-0.0.1", 
          //           type="checkbox")
          //       label(class="c-chk__label is-hidden",
          //         for="chk-0.0.1")
          //   td(class="c-table__row__cell") filler cell text


          debug && console.log("adding stuff to itemTR and itemTBody")
          itemTBody.append(itemTR)
        })
        

      }
    }

    function dynamicUpdaterLocal(items, field){
      // TODO: check dynamic code, this maybe not needed in dynamic code
      // find out if its text or a drop down field
      
      // replaceSelectValue = $('#replaceSelectValue')
      // replaceText = $('#replaceText')
      let tempValue = null

      // check special case then drop down or text
      if(field == 'group_permissions'){

        // check if all or groups
        tempValue = replaceSelectValue.val()
        if(tempValue != 'All'){
          // check that at least one group has been added
          debug && console.log("groupTagList.children(): ", groupTagList.children())
          if(groupTagList.children().length == 0){
            return {error:'Please select at least one group'}
          }
          tempValue = []
          groupTagList.children().each(function(){
            const tempChild = $(this)
            tempValue.push(tempChild.attr('data1'))
          })
        }
      }else if(replaceSelectValue.is(':visible')){
        debug && console.log("use the drop down value")
        tempValue = replaceSelectValue.val()
      }else{
        debug && console.log("use the text value")
        tempValue = replaceText.val()
      }
      debug && console.log(`replace value: ${tempValue} with lookup.id ${lookup.id}`)
      const newMacros = macros.slice()
      debug && console.log("newMacros: ", newMacros)
      newMacros.forEach(macro=>{
        // non field updates
        if(field == 'group_permissions'){
          // update restriction id and ids for group permissions
          if(tempValue == 'All'){
            macro.restriction = null
          }else{
            let firstVal = null
            tempValue.forEach(tempV=>{
              if(!firstVal){
                macro.restriction.type = 'Group'
                debug && console.log('restriction  type set to group')
                macro.restriction = {id:tempV, ids:[]}
                firstVal = 'done'
              }
              macro.restriction.ids.push(tempV)
            })
          }
        }else{
          // search for the field in actions
          let found = false
          macro.actions.forEach(action=>{
            // check if just replacing word instances
            if(isReplaceWord){
              if(action.field == field){
                found = true
                // action.value = tempValue
                action.value = replaceWordInstances(action.value, replaceWordNew.val())
              }else if(action.field == 'comment_value' && field == 'comment_value_html'){
                // special case for comments that can be 2 fields
                found = true
                action.value = replaceWordInstances(action.value, replaceWordNew.val())
                // action.value = tempValue
              }
              
            }else{
              if(action.field == field){
                found = true
                action.value = tempValue
              }else if(action.field == 'comment_value' && field == 'comment_value_html'){
                // special case for comments that can be 2 fields
                found = true
                action.value = tempValue
              }
            }
          })
          if(!found){
            // insert it
            macro.actions.push({field, tempValue})
          }
        }
      })
      return newMacros
    }

    // update to use a list of groups rather than API endpoint
    jQuery.typeahead({
      minLength: 1,
      delay:300,
      input: '.tagTypeAhead',
      order: 'desc',
      // source: {
      //   data:['group 1', 'group 2', 'group3', 'bet', 'best', 'ber', 'berry', 'berret']
      // },
      source: {
        group:{ // advanced typeahead usage custom data object
          display:'name',
          // data: [{name:'group 1', id:2}, {name:'group 2', id:3}]
          data: getGroupsLocal
          // data = [{}, {}]
        }
      },
      callback: {
        onInit: function(node){
          debug && console.log("type ahead initiated on: " + node.selector)
        },
        onSearch: function(node,query){
          debug && console.log("searching with: ", query)
          debug && console.log("searching against allGroups: ", allGroups)
        },
        onSubmit: function(node, form, item, event){
          event.preventDefault()
          debug && console.log("Not submitting in typeahead")
        },
        onClickAfter: function(node, form, item, event){
          debug && console.log("Group tags being updated with", item.name)
          addTag(item.name, item.id, true)
          jQuery('#groupTag').val('')
        }
      }
    })


    // tab/panel code
    const tab1 = $('#tab1')
    const tab2 = $('#tab2')
    const panel1 = $('#panel1')
    const panel2 = $('#panel2')

    let activePanel = panel1
    let activeTab = tab1

    tab1.click(function(){
      activateTab(this)
      tab1.addClass('is-selected')
      // unhighlight
      tab2.removeClass('is-selected')
    })
    tab2.click(function(){
      activateTab(this)
      tab2.addClass('is-selected')
      // unhighlight
      tab1.removeClass('is-selected')
    })

    function activateTab(elem){
      debug && console.log("going to activate tab for: ", elem)
      const tabItem = $(elem)
      debug && console.log(tabItem)
      debug && console.log(tabItem.attr('id'))
      debug && console.log(tabItem.attr('aria-controls'))
      const tempPanel = tabItem.attr('aria-controls')
      // deactivate current panel
      debug && console.log("deactivating: ", activePanel)
      activePanel.attr('aria-hidden', true)

      activePanel = tempPanel
      switch(activePanel){
        case 'panel1':
          activePanel = panel1
          break
        case 'panel2':
          activePanel = panel2
          break
      }
      activePanel.attr('aria-hidden', false)
      // activate new panel
      debug && console.log("activating: ", activePanel)
      // activePanel =
    }

    // csv parsing
    uploadMacroCSV.click(function(){
      // click file input
      debug && console.log("starting macro csv upload: ")
      macroCSVFile.click()
    })

    macroCSVFile.change(function(){
      // update status
      uploadMacroCSVStatus.val('Processing...')
      
      // check is csv
      const filename = macroCSVFile.val().split('\\')
      // check parse success
      const extension = macroCSVFile.val().split('\\').pop().split('.').pop().toLowerCase()
      if(extension != 'csv'){
        debug && console.log('file must be csv')
      }else{
        debug && console.log('csv file selected')
      } 
      

      const fileObj = this.files[0]
      debug && console.log('files[0]', fileObj) 
      debug && console.log('files[0].name', fileObj.name) 
      // display "must be valid CSV in format: macro__url, etc"
      CSV.fetch({file:fileObj})
      .done(function(dataset){
        debug && console.log('csv dataset', dataset) 
        let currentMacroNum = -1

        // add 2 fields to hold actions and groupids
        const actionsPos = dataset.fields.length
        const groupsPos = dataset.fields.length+1
        const fieldMappings = {}
        fieldMappings[actionsPos] = 'actions'
        fieldMappings[groupsPos] = 'groups'

        // find range of group ids
        let groupIDStart = null
        let groupIDLen = null
        for(i = 0; i < dataset.fields.length; i++){
          const tempField = dataset.fields[i]
          if(tempField.includes('macros__restriction__ids')){
            if(groupIDStart === null){ 
              groupIDStart = i
              groupIDLen = 1
            }else{
              groupIDLen++
            }
          }
        }

        debug && console.log(`groupIDStart: ${groupIDStart}, groupIDLen: ${groupIDLen}`)

        const tempAllMacros = []
        dataset.records.forEach(item=>{
          if(item[0] != '' && item[0] != null){
            currentMacroNum++
            debug && console.log('macro to update: ', item) 
            const tempAction = {}
            item[actionsPos] = [{'field':item[8], 'value':item[9]}]
            const tempGroupIDs = []
            item[groupsPos] = item.slice(groupIDStart, groupIDStart+ groupIDLen)
            tempAllMacros.push(item)
            item[groupsPos] = item[groupsPos].filter(function(el){
              if(el != null && el != '')
                return true
              return false
            })
          }
          else if(item[2] != '' && item[2] != null){
            // can combine with above most likely
            currentMacroNum++
            debug && console.log('new macro: ', item) 
            item[actionsPos] = [{'field':item[8], 'value':item[9]}]
            item[groupsPos] = item.slice(groupIDStart, groupIDStart + groupIDLen)
            // filter null - https://stackoverflow.com/a/281335/2701322
            item[groupsPos] = item[groupsPos].filter(function(el){
              if(el != null && el != '')
                return true
              return false
            })

            tempAllMacros.push(item)
          }else{
            // check for actions, add to temp all actions field
            if(item[8] != '' && item[9] != '' && item[8] != null && item[9] != null ){
              tempAllMacros[currentMacroNum][actionsPos].push({action:item[8], value:item[9]})
            }
          }
        })
        debug && console.log('tempAllMacros: ', tempAllMacros) 

        // if no optional fields are set may not show up in csv
        // keep actions__field/value until support for group ids/infinite columns is added
        const macroLookup = [
          'url',
          'id',
          'title',
          'active',
          'position',
          'description',
          'resctriction',
          'restriction__type',
          'restriction__id',
          'actions__field',
          'actions__value'
        ]
        // build lookup for parsed csv js
        debug && console.log('searching fieldmappings, macroLookup: ', macroLookup) 
        macroLookup.forEach(field=>{
          const columnPos = dataset.fields.indexOf('macros__'+field)
          if(columnPos != -1){
            // store with position as key, zendesk field as value
            debug && console.log('found macros__field: ', 'macros__'+field) 
            fieldMappings[columnPos] = field
            // delete(fieldMappings[field])
          }
        })
        debug && console.log('fieldMappings: ', fieldMappings) 


        // check of restriction exists

        // TODO: check how many restriction ids columns exist
        // check dataset.fields.contains('macros__restriction__id'), startpos, len


        // csv will have many restriction__ids fields if there are any group restrictions set, 
        // column count equals macro with the most number of specific groups set

        // if no url is set insert
        const newMacros = []
        const toUpdateMacros = []
        tempAllMacros.forEach(macro=>{
          const tempMacro = {}
          for(i = 0; i < macro.length; i++){
            if(fieldMappings[i]){
              tempMacro[fieldMappings[i]] = macro[i]
              // make correct type
              // boolean
              if(fieldMappings[i] == 'active'){
                if( macro[i].toLowerCase() == 'true' || macro[i] == true)
                  tempMacro[fieldMappings[i]] = true
                else
                  tempMacro[fieldMappings[i]] = false
              }
              //int
              if(fieldMappings[i] == 'id' || fieldMappings[i] == 'position'){
                tempMacro[fieldMappings[i]] = parseInt(macro[i])
              }
            }
          }
          // user/group restriction logic
          if(tempMacro.restriction_type == 'User'){
            tempMacro.restriction = {id:tempMacro.restriction__id, type:'User'}
            delete(tempMacro.restriction__type)
            delete(tempMacro.restriction__id)
          }
          if(tempMacro.restriction_type == 'Group'){
            tempMacro.restriction = {
                id:tempMacro.restriction__id, 
                type:'Group',
                ids:macro[fieldMappings[groupsPos]]
                }
            delete(tempMacro.restriction__type)
            delete(tempMacro.restriction__id)

          }

          // remove temp action fields
          // if(tempMacro['actions__field'])
          //   delete(tempMacro['actions__field'])
          // if(tempMacro['actions__value'])
          //   delete(tempMacro['actions__value'])
          debug && console.log('tempMacro: ', tempMacro) 

          // if it has an id, update, otherwise insert
          if(tempMacro.id)
            toUpdateMacros.push(tempMacro)
          else
            newMacros.push(tempMacro)
        })
        debug && console.log('newMacros: ', newMacros) 
        debug && console.log('toUpdateMacros: ', toUpdateMacros) 
        uploadMacroCSVStatus.val('Upserting macros...')
        csvUploadDirty = true
        
        // upsert macros from csv
        // update
        sendManyAPIRequests(toUpdateMacros)
        // // insert (currently both use same function) eventually might be better with different structure
        sendManyAPIRequests(newMacros)
      })

    })
    // on file select - check csv and parse into string and check success parse csv



    // OLD CODE:
    // update is currently single only, creation is macros array
    function updateMacroStatus(macro, macros, status){
      debug && console.log("inside updateMacroStatus")
      if(macro){
        // find the macro line
        const toUpdateDiv = $('#'+prefixID+macro.listPos)
        debug && console.log("going to update: ", toUpdateDiv)



        const toUpdateSpan =  toUpdateDiv.find('span')
        debug && console.log("toUpdateSpan", toUpdateSpan)
        toUpdateSpan.text(status)
        // const tempWrapper = $('<div />')
        // const tempElem = jQuery('<h3 />').text('Title: '+macro.title)
        // tempWrapper.attr('id', 'macro-result-' + macro.listPos)
        // const tempCheckbox = $('<span />').text(status)
        // update a single macro status
      }else if(macros){
        // NOTE: currently this is initial only, does not support update
        // update all macro status usually for initial
        // reset #results
        debug && console.log("inside macros updateMacroStatus")
        const resultWrapper = jQuery('#results')
        resultWrapper.html('')
        macros.forEach(macro=>{
          debug && console.log("updating a macro result status at: ", macro.listPos)
          debug && console.log("updating a macro result status at: ", macro.title)
          const tempWrapper = $('<div />')
          const tempElem = jQuery('<h3 />').text('Title: '+macro.title)
          tempWrapper.attr('id', prefixID + macro.listPos)
          const tempCheckbox = $('<span />').text(status)

          tempWrapper.append(tempCheckbox)
          tempWrapper.append(tempElem)
          resultWrapper.append(tempWrapper)
        })
        // add all with an id of macro-result-i
        

      }
    }
